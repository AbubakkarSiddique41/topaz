# compstmt: line* statement? [LINE_END]?;
# unfortunately you need to inline this anywhere you want it because ebnf parse
# doesn't support epsilon productions.

main: line* statement? [LINE_END]? [EOF];

line: statement? [LINE_END];

statement: RETURN expr |
           expr;

expr: assignment |
      yield |
      arg;

assignment_oper: <EQ> | <PLUS_EQUAL> | <MINUS_EQUAL>;

assignment: send assignment_oper expr;

yield: [YIELD] args?;

arg: range;

range_oper: <DOTDOT> | <DOTDOTDOT>;
cmp_oper: <EQUAL> | <NE> | <LT> | <LE> | <GT> | <GE>;
shift_oper: <LSHIFT>;
add_oper: <PLUS> | <MINUS>;
mul_oper: <DIV> | <MUL>;

range: comparison range_oper range | <comparison>;
comparison: shiftive cmp_oper comparison | <shiftive>;
shiftive: additive shift_oper shiftive | <additive>;
additive: multitive add_oper additive | <multitive>;
multitive: send mul_oper multitive | <unary_op>;

unary_op: UNARY_MINUS arg | <send>;

send: <do_block> |
      real_send |
      <primary>;

do_block: real_send DO ([PIPE] arglist? [PIPE])? line* statement? [LINE_END]? END;

real_send: primary trailers |
           global_block |
           IDENTIFIER  send_args block? |
           IDENTIFIER [LPAREN] send_args? [RPAREN] block?;

global_block: IDENTIFIER block;

block: [LBRACE] ([PIPE] arglist? [PIPE])? line* statement? [LINE_END]? [RBRACE];

trailers: trailer >trailers< | trailer;

trailer: attribute | subscript | constant;
attribute: [DOT] operation [LPAREN] send_args? [RPAREN] block? |
           [DOT] operation block |
           [DOT] operation send_args?;
subscript: [LBRACKET] arg [RBRACKET];
constant: COLONCOLON IDENTIFIER;

primary: LPAREN expr RPAREN |
         LBRACKET args? RBRACKET |
         IF expr then line* statement? [LINE_END]? END |
         UNLESS expr then line* statement? [LINE_END]? END |
         WHILE expr do line* statement? [LINE_END]? END |
         DEF function_name argdecl line* statement? [LINE_END]? END |
         CLASS IDENTIFIER (LT IDENTIFIER)? [LINE_END] line* statement? [LINE_END]? END |
         MODULE IDENTIFIER line* statement? [LINE_END]? END |
         BEGIN line* statement? [LINE_END]? rescue* ensure? END |
         varname |
         literal;

then: [LINE_END] |
      THEN |
      [LINE_END] THEN;

do: [LINE_END] |
    DO |
    [LINE_END] DO;

rescue: RESCUE IDENTIFIER? (ARROW IDENTIFIER)? line* statement? [LINE_END]?;

ensure: ENSURE line* statement? [LINE_END]?;

function_name: IDENTIFIER [DOT] IDENTIFIER |
               IDENTIFIER;

argdecl: [LPAREN] arglist? [RPAREN] |
         arglist? [LINE_END];

arglist: argdef [COMMA] >arglist< | argdef;

argdef: IDENTIFIER [EQ] arg |
        AMP IDENTIFIER |
        IDENTIFIER;

operation: IDENTIFIER | CLASS | END | BEGIN;

send_args: args;

args: argument [COMMA] >args< | argument;

argument: <arg> | <splat>;

splat: [UNARY_STAR] arg;

varname: IDENTIFIER |
         AT_SIGN IDENTIFIER;

literal: NUMBER | symbol | STRING;

symbol: [COLON] IDENTIFIER;