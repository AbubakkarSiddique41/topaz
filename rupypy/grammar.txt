# compstmt: line* statement? [LINE_END]?;
# unfortunately you need to inline this anywhere you want it because ebnf parse
# doesn't support epsilon productions.

IGNORE: "[ ]";
LINE_END: "[\n;]";

INTEGER: "[0-9]+";
STRING: "\\"[^\\\\"]*\\"";
IDENTIFIER: "[a-zA-Z_][a-zA-Z0-9_]*";

CMP_OPER: "(!=)|(==)|(<=)|(>=)|<|>";
SHIFT_OPER: "<<";
ADD_OPER: "[+-]";
MUL_OPER: "[*]";

main: line* statement? [LINE_END]? [EOF];

line: statement? [LINE_END];

statement: "return" expr |
            expr;

expr: assignment |
      arg;

assignment: lhs "=" rhs;

lhs: varname;

rhs: arg;

arg: comparison;

comparison: shiftive CMP_OPER comparison | <shiftive>;
shiftive: additive SHIFT_OPER shiftive | <additive>;
additive: multitive ADD_OPER additive | <multitive>;
multitive: send MUL_OPER multitive | <send>;

send: primary trailers |
      IDENTIFIER send_args |
      <primary>;

trailers: trailer >trailers< | trailer;

trailer: attribute | subscript;
attribute: ["\."] operation send_args?;
subscript: ["["] arg ["]"];

primary: "(" expr ")" |
         "[" args? "]" |
         "if" expr then line* statement? [LINE_END]? "end" |
         "while" expr do line* statement? [LINE_END]? "end" |
         "def" IDENTIFIER argdecl line* statement? [LINE_END]? "end" |
         "class" IDENTIFIER [LINE_END] line* statement? [LINE_END]? "end" |
         varname |
         literal;

then: [LINE_END] |
      "then" |
      [LINE_END] "then";

do: [LINE_END] |
    "do" |
    [LINE_END] "do";

argdecl: ["("] arglist? [")"] |
         arglist? [LINE_END];

arglist: IDENTIFIER [","] >arglist< | IDENTIFIER;

operation: IDENTIFIER | "class";

send_args: args;

args: arg [","] >args< | arg;

varname: IDENTIFIER |
         "@" IDENTIFIER;

literal: INTEGER | STRING;
