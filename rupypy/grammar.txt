# compstmt: line* statement? [LINE_END]?;
# unfortunately you need to inline this anywhere you want it because ebnf parse
# doesn't support epsilon productions.

main: line* statement? [LINE_END]? [EOF];

line: statement? [LINE_END];

statement: RETURN expr |
           expr;

expr: assignment |
      yield |
      arg;

assignment_oper: <EQ> | <PLUS_EQUAL> | <MINUS_EQUAL>;

assignment: send assignment_oper expr;

yield: YIELD args?;

arg: range;

range_oper: <DOTDOT> | <DOTDOTDOT>;
cmp_oper: <EQUAL> | <NE> | <LT> | <LE> | <GT> | <GE>;
shift_oper: <LSHIFT>;
add_oper: <PLUS> | <MINUS>;
mul_oper: <DIV> | <MUL>;
bool_oper: <OR>;

range: bool range_oper range | <bool>;
bool: comparison bool_oper bool | <comparison>;
comparison: shiftive cmp_oper comparison | <shiftive>;
shiftive: additive shift_oper shiftive | <additive>;
additive: multitive add_oper additive | <multitive>;
multitive: unary_op mul_oper multitive | <unary_op>;

unary_op: UNARY_MINUS arg | <send>;

send: <do_block> |
      real_send |
      <primary>;

do_block: real_send DO block_args? line* statement? [LINE_END]? END;

block_args: [PIPE] arglist? [PIPE] |
            [OR];

real_send: primary trailers |
           global_block |
           IDENTIFIER  send_args block? |
           IDENTIFIER [LPAREN] send_args? [RPAREN] block?;

global_block: IDENTIFIER block;

block: [LBRACE] block_args? line* statement? [LINE_END]? [RBRACE];

trailers: trailer >trailers< | trailer;

trailer: attribute | subscript | constant;
attribute: [DOT] operation [LPAREN] send_args? [RPAREN] block? |
           [DOT] operation block |
           [DOT] operation send_args?;
subscript: [LBRACKET] arg [RBRACKET];
constant: COLONCOLON IDENTIFIER;

primary: LPAREN expr RPAREN |
         LBRACKET args? RBRACKET |
         IF if elsifs? else? [END] |
         UNLESS expr then line* statement? [LINE_END]? END |
         WHILE expr do line* statement? [LINE_END]? END |
         DEF function_name argdecl line* statement? [LINE_END]? END |
         CLASS LSHIFT arg [LINE_END] line* statement? [LINE_END]? END |
         CLASS IDENTIFIER (LT varname)? [LINE_END] line* statement? [LINE_END]? END |
         MODULE IDENTIFIER line* statement? [LINE_END]? END |
         BEGIN line* statement? [LINE_END]? rescue* ensure? END |
         varname |
         literal;

if: expr then line* statement? [LINE_END]?;

then: [LINE_END] |
      THEN |
      [LINE_END] THEN;

do: [LINE_END] |
    DO |
    [LINE_END] DO;

elsifs: elsif >elsifs< | elsif;

elsif: ELSIF expr then line* statement? [LINE_END]?;

else: ELSE line* statement? [LINE_END]?;

rescue: RESCUE varname? (ARROW IDENTIFIER)? line* statement? [LINE_END]?;

ensure: ENSURE line* statement? [LINE_END]?;

function_name: varname [DOT] IDENTIFIER |
               IDENTIFIER;

argdecl: [LPAREN] arglist? [RPAREN] |
         arglist? [LINE_END];

arglist: argdef [COMMA] >arglist< | argdef;

argdef: IDENTIFIER [EQ] arg |
        UNARY_STAR IDENTIFIER |
        AMP IDENTIFIER |
        IDENTIFIER;

operation: IDENTIFIER | CLASS | END | BEGIN;

send_args: args ([COMMA] block_arg)? |
           block_arg;

args: argument [COMMA] >args< | argument;

argument: <arg> | <splat>;

splat: [UNARY_STAR] arg;

block_arg: [AMP] arg;

varname: IDENTIFIER |
         AT_SIGN IDENTIFIER |
         DOLLAR IDENTIFIER;

literal: NUMBER | symbol | STRING | regexp;

symbol: [COLON] IDENTIFIER;

# XXX: doesn't match all regexes by far
regexp: [DIV] IDENTIFIER [DIV];